<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>MeCab: Yet Another Japanese Dependency Structure Analyzer</title>
<link type="text/css" rel="stylesheet" href="mecab.css">
</head>
<body>
<h1>MeCab ライブラリ</h1>

<p>$Id: libmecab.html 161 2008-02-03 09:58:46Z taku-ku $;</p>

<h2><a name="c-interface">C ライブラリ仕様</a></h2>
<p>C ライブラリは以下の関数を提供しています.</p>

<dl>
<dt><code><font color="#dc143c">mecab_t *</font><font color=
"DarkBlue">mecab_new</font> (int argc, char **argv)</code></dt>

<dd>mecab のインスタンスを生成します.<br>
引数には, C 言語の, main 関数で使用される argc,
argv スタイルの引数を与えます.<br>
この引数は, <a href="mecab.html">mecab
コマンド</a>と同じ方法で処理されます.<br>
成功すれば, mecab_t 型のポインタが返ってきます.
このポインタを通して解析 を行います. 失敗すれば
NULL が返ってきます.<br>
</dd>

<dt><code><font color="#dc143c">mecab_t *</font><font color=
"DarkBlue">mecab_new2</font> (const char *arg)</code></dt>

<dd>mecab のインスタンスを生成します.<br>
引数には,
一つの文字列として表現したパラメータを与えます.<br>
成功すれば, mecab_t 型のポインタが返ってきます.
このポインタを通して解析を行います.<br>
</dd>

<dt><code><font color="#dc143c">const char *</font><font color=
"DarkBlue">mecab_version</font>()</code></dt>

<dd>mecab の version を文字列として取得します.<br>
</dd>

<dt><code><font color="#dc143c">const char *</font><font color=
"DarkBlue">mecab_strerror</font> (mecab_t* m)</code></dt>

<dd>エラーの内容を文字列として取得します. mecab_sparse_tostr
等で, NULL が返ってきた場合に, mecab_strerror
を呼ぶことで, エラーの内容を取得できます.
mecab_new,mecab_new2 のエラーは, m を NULL
と指定してください. <br>
</dd>

<dt><code><font color="#dc143c">const char *</font><font color=
"DarkBlue">mecab_sparse_tostr</font> (mecab_t *m, const char
*str)</code></dt>

<dd>解析を行います. 引数には, mecab_new
で得られた mecab_t 型のポインタと,<br>
解析したい文を char
型のポインタ文字列として与えます.<br>
成功すれば, 解析後の結果が char
型のポインタとして返り, 失敗すれば, NULL
が返ってきます<br>
戻り値のポインタが指すメモリ領域は,
呼び出し側で管理する必要はありませんが,<br>
mecab_sparse_tostr を呼ぶ度に上書きされます.<br>
また, mecab_destroy を呼ぶと解放されます. <br>
</dd>

<dt><code><font color="#dc143c">const char *</font><font color=
"DarkBlue">mecab_sparse_tostr2</font> (mecab_t *m, const char *str,
size_t len)</code></dt>

<dd>mecab_sparse_tostr とほぼ同じですが, len にて,
解析する文の長さを指定できます. <br>
</dd>

<dt><code><font color="#dc143c">char *</font><font color=
"DarkBlue">mecab_sparse_tostr3</font> (mecab_t *m, const char
*istr,size_t ilen char *ostr, size_t olen)</code></dt>

<dd>mecab_sparse_tostr2 に加え, 出力用の
バッファ領域 (ostr), 及びその長さ (olen)
を指定できます. ostr の領域の管理は,
呼び出し側が行います. 成功すれば, 解析後の結果が
char 型のポインタとして返ってきます. これは, ostr
と同じになります. もし, 解析結果の長さが olen
以上になった場合は, 解析失敗とみなし, NULL
を返します. <br>
</dd>

<dt><code><font color="#dc143c">const char *</font><font
					      color="DarkBlue">mecab_nbest_sparse_tostr</font>
    (mecab_t *m, size_t N, const char *str)
    </code></dt>
<dd>
mecab_sparse_tostr () の N-Best 解出力 version です. N にて解析結果の個
数を指定します. また, N-Best の機能を使う場合は, 必ず mecab_new にて
-l 1 オプションを指定する必要があります. 
</dd>

<dt><code><font color="#dc143c">const char *</font><font color="DarkBlue">mecab_nbest_sparse_tostr2</font>
    (mecab_t *m, size_t N, const char *str, size_t len)
    </code></dt>
<dd>
mecab_sparse_tostr2 () の N-Best 解出力 version です. N にて解析結果の個
数を指定します.
</dd>


<dt><code><font color="#dc143c">char *</font><font color="DarkBlue">mecab_nbest_sparse_tostr3</font>
    (mecab_t *m, size_t N, const char *str, size_t len, char *ostr, size_t olen)
    </code></dt>
<dd>
mecab_sparse_tostr3 () の N-Best 解出力 version です. N にて解析結果の個
数を指定します.
</dd>

<dt><code><font color="#dc143c">int </font><font color="DarkBlue">mecab_nbest_init</font>
(mecab_t* m, const char* str);
</code></dt>
<dd>
解析結果を, 確からしいものから順番に取得する場合にこの関数で初期化を行い
ます.  解析したい文を str に指定します. 初期化に成功すると 1 を, 失敗する
と 0 を返します. 失敗の原因は, mecab_strerror で取得できます.
</dd>

<dt><code><font color="#dc143c">int </font><font color="DarkBlue">mecab_nbest_init2</font>
(mecab_t* m, const char* str, len);
    </code></dt>
<dd>
mecab_nbest_init () とほぼ同じですが, len にて文の長さを指定できます.
</dd>

<dt><code><font color="#dc143c">const char *</font><font
					      color="DarkBlue">mecab_nbest_next_tostr</font>
(mecab_t* m)
    </code></dt>
<dd>
 mecab_nbest_init() の後, この関数を順次呼ぶことで, 確からしい解析結果
 を, 順番に取得できます. 失敗すると (これ以上の解が存在しない場合) NULL
 を返します. 失敗の原因は, mecab_strerror で取得できます.
</dd>

<dt><code><font color="#dc143c">char *</font><font
					      color="DarkBlue">mecab_nbest_next_tostr2</font>
(mecab_t *m , char *ostr, size_t olen)
    </code></dt>
<dd>
 mecab_nbest_tostr() とほぼ同じですが, ostr, olen にて出力用のバッファを
 指定できます. 失敗すると (これ以上の解が存在しない場合) NULL を返します.
また, 出力バッファが溢れた場合も NULL を返します.
失敗の原因は, mecab_strerror で取得できます.
</dd>

<dt><code><font color="#dc143c">void</font> <font color=
"DarkBlue">mecab_destroy</font>(mecab_t *m)</code></dt>
<dd>mecab_t 型のポインタを解放します. <br>
<br>
</dd>
</dl>

<p>形態素情報を取り出すには,以下の mecab_node_t 構造体と
mecab_sparse_tonode 関数を使います</p>
<pre>
#define MECAB_NOR_NODE  0
#define MECAB_UNK_NODE  1
#define MECAB_BOS_NODE  2
#define MECAB_EOS_NODE  3

struct mecab_node_t {
  struct mecab_node_t  *prev;  // 一つ前の形態素へのポインタ
  struct mecab_node_t  *next;  // 一つ先の形態素へのポインタ

  struct mecab_node_t  *enext; // 同じ位置で終わる形態素へのポインタ
  struct mecab_node_t  *bnext; // 同じ開始位置で始まる形態素へのポインタ

  char  *surface;             // 形態素の文字列情報
                              // NULL terminateされていません. 文字列として取り出すには
			      // strncpy(buf, node->feature, node->length) とする必要があります

  char  *feature;             // CSV で表記された素性情報
  unsigned int   length;      // 形態素の長さ
  unsigned int   rlength;     // 形態素の長さ(先頭のスペースを含む)
  unsigned int   id;          // 形態素に付与される ユニークID
  unsigned short rcAttr;      // 右文脈 id
  unsigned short lcAttr;      // 左文脈 id
  unsigned short posid;       // 形態素 ID
  unsigned char  char_type;   // 文字種情報
  unsigned char  stat;        // 形態素の種類: 以下のマクロの値
                              // #define MECAB_NOR_NODE  0
                              // #define MECAB_UNK_NODE  1
                              // #define MECAB_BOS_NODE  2
                              // #define MECAB_EOS_NODE  3
  unsigned char  isbest;      // ベスト解の場合 1, それ以外 0

  float          alpha;       // forward backward の foward log 確率
  float          beta;        // forward backward の backward log 確率
  float          prob;        // 周辺確率
                              // alpha, beta, prob は -l 2 オプションを指定した時に定義されます

  short          wcost;       // 単語生起コスト
  long           cost;        // 累積コスト
};
</pre>

<dl>
<dt><code><font color="#dc143c">const mecab_node_t *</font><font color=
"DarkBlue">mecab_sparse_tonode</font> (mecab_t *m, const char *str)</code></dt>

<dd>解析を行います. 引数には, mecab_new で得られた mecab_t 型のポインタと,<br>
解析したい文を char 型のポインタ文字列として与えます.<br>
成功すれば, 文頭の形態素(mecab_node_t型)へのポインタが返り,
失敗すれば, NULLが返ってきます.<br>
mecab_node_t は双方向リストになっているため next, prev を順にたどる事で
全形態素を列挙することができます.<br>
戻り値のポインタが指すメモリ領域は,
呼び出し側で管理する必要はありませんが,mecab_sparse_tonode を呼ぶ度に上書きされます.<br>
また, mecab_destroy を呼ぶと解放されます. <br>
</dd>

<dt><code><font color="#dc143c">const mecab_node_t *</font><font color=
"DarkBlue">mecab_sparse_tonode2</font> (mecab_t *m, const char *str,
size_t len)</code></dt>

<dd>mecab_sparse_tonode とほぼ同じですが, len にて,
解析する文の長さを指定できます. <br>
</dd>

<dt><code><font color="#dc143c">const mecab_node_t *</font><font
					      color="DarkBlue">mecab_next_tonode</font>
(mecab_t* m)
    </code></dt>
<dd>
mecab_next_tostr とほぼ同じですが,文字列ではなく mecab_node_t 型の形態素情報を返します.
</dd>
</dl>

<p>辞書の情報を取り出すには mecab_dictionary_t 構造体と
mecab_dictionary_info() 関数を使います</p>

<pre>
#define MECAB_USR_DIC   1
#define MECAB_SYS_DIC   0
#define MECAB_UNK_DIC   2

struct mecab_dictionary_info_t {
  const char                     *filename;  // 辞書のファイル名
  const char                     *charset;   // 辞書の文字コード
  unsigned int                    size;      // 単語数
  int                             type;      // 辞書のタイプ
                                             // MECAB_(USR|SYS|UNK)_DIC のいずれか
  unsigned int                    lsize;     // 左文脈 ID のサイズ
  unsigned int                    rsize;     // 右文脈 ID のサイズ
  unsigned short                  version;   // バージョン
  struct mecab_dictionary_info_t *next;　　　// 次の辞書へのポインタ
};
</pre>

<dl>
<dt><code><font color="#dc143c">const mecab_dictionary_info_t *</font><font color=
"DarkBlue">mecab_dictionary_info</font>(mecab_t *m)</code></dt>
<dd>辞書情報を取得します. 引数には, mecab_new で得られた mecab_t 型のポ
インタを与えます. <br>
mecab_dictoinary_info_t は単方向リストになっています.<br> 複数の辞書を
使っている場合は, next を辿っていくことで全ての辞書情報にアクセスできます.<br>
mecab_dictionary_info() が返す領域は mecab が管理していますので解放する
必要はありません.
</dd>
</dl>

<p>以下のAPIで解析のパラメータや条件を変更することができます。</p>

<dl>
<dt><code><font color="#dc143c">int </font><font color=
"DarkBlue">mecab_get_partial</font>(mecab_t *m)</code></dt>
<dd>
部分解析の現在のモードを取得します。(0: off, 1:on)
</dd>

<dt><code><font color="#dc143c">void </font><font color=
"DarkBlue">mecab_set_partial</font>(mecab_t *m)</code></dt>
<dd>
部分解析の現在のモードを設定します。(0: off, 1:on)
</dd>

<dt><code><font color="#dc143c">float </font><font color=
"DarkBlue">mecab_get_theta</font>(mecab_t *m)</code></dt>
<dd>
<a href="soft.html">ソフト分かち書き</a>の温度パラメータを取得します。
</dd>

<dt><code><font color="#dc143c">void </font><font color=
"DarkBlue">mecab_set_theta</font>(mecab_t *m, float theta)</code></dt>
<dd>
<a href="soft.html">ソフト分かち書き</a>の温度パラメータを設定します。
</dd>

<dt><code><font color="#dc143c">int </font><font color=
"DarkBlue">mecab_get_lattice_level</font>(mecab_t *m)</code></dt>
<dd>
ラティスレベル(どの程度のラティス情報を解析時に構築するか)を取得します。
<ul>
<li>0: 最適解のみが出力可能なレベル (デフォルト, 高速)
<li>1: N-best 解が出力可能なレベル (中速)
<li>2: ソフトわかち書きが可能なレベル (低速)
</ul>
</dd>

<dt><code><font color="#dc143c">void </font><font color=
"DarkBlue">mecab_set_lattice_level</font>(mecab_t *m, int lattice_level)</code></dt>
<dd>
ラティスレベルを設定します。
</dd>

<dt><code><font color="#dc143c">int </font><font color=
"DarkBlue">mecab_get_all_morphs</font>(mecab_t *m)</code></dt>
<dd>
出力モードを取得します。(0: ベスト解のみ, 1:全出力)
</dd>

<dt><code><font color="#dc143c">void </font><font color=
"DarkBlue">mecab_set_all_morphs</font>(mecab_t *m, int all_mophrs)</code></dt>
<dd>
出力モードを設定します。(0: ベスト解のみ, 1:全出力)
</dd>
</dl>

<h2><a name="c-sample">C サンプル</a></h2>
<p>example/example.c </p>

<pre>
#include &lt;mecab.h&gt;
#include &lt;stdio.h&gt;

#define CHECK(eval) if (! eval) { \
    fprintf (stderr, "Exception:%s\n", mecab_strerror (mecab)); \
    mecab_destroy(mecab); \
    return -1; }

int main (int argc, char **argv) {
  char input[1024] = "太郎は次郎が持っている本を花子に渡した。";
  mecab_t *mecab;
  mecab_node_t *node;
  const char *result;
  int i;

  mecab = mecab_new (argc, argv);
  CHECK(mecab);

  result = mecab_sparse_tostr(mecab, input);
  CHECK(result)
  printf ("INPUT: %s\n", input);
  printf ("RESULT:\n%s", result);

  result = mecab_nbest_sparse_tostr (mecab, 3, input);
  CHECK(result);
  fprintf (stdout, "NBEST:\n%s", result);

  CHECK(mecab_nbest_init(mecab, input));
  for (i = 0; i < 3; ++i) {
    printf ("%d:\n%s", i, mecab_nbest_next_tostr (mecab));
  }

  node = mecab_sparse_tonode(mecab, input);
  CHECK(node);
  for (; node; node = node->next) {
    fwrite (node->surface, sizeof(char), node->length, stdout);
    printf("\t%s\n", node->feature);
  }

  node = mecab_sparse_tonode(mecab, input);
  CHECK(node);
  for (;  node; node = node->next) {
    printf("%d ", node->id);
    
    if (node->stat == MECAB_BOS_NODE)
      printf("BOS");
    else if (node->stat == MECAB_EOS_NODE)
      printf("EOS");
    else
      fwrite (node->surface, sizeof(char), node->length, stdout);

    printf(" %s %d %d %d %d %d %d %d %d %f %f %f %d\n",
	   node->feature,
	   (int)(node->surface - input),
	   (int)(node->surface - input + node->length),
	   node->rcAttr,
	   node->lcAttr,
	   node->posid,
	   (int)node->char_type,
	   (int)node->stat,
	   (int)node->isbest,
	   node->alpha,
	   node->beta,
	   node->prob,
	   node->cost);
  }

  mecab_destroy(mecab);

  return 0;
}
</pre>

<h2><a name="c++">C++ ライブラリ仕様</a></h2>
<p>以下が C++ API です. 基本的に C のインタフェイスと同一ですが,</p>
<ul>
<li>mecab_t が MeCab::Tagger
<li>mecab_node_t が MeCab::Node
<li>mecab_new() が  MeCab::createTagger() ファクトリ関数
<li>mecab_destroy () はなく,delete を呼んで開放する
</ul>
<p>といった違いがあります.</p>
</p>

<pre>
namespace MeCab {
  typedef struct mecab_node_t                Node;
  typedef struct mecab_dictionary_info_t     DictionaryInfo;

  class Tagger {
  public:
    virtual const char* parse(const char*, size_t, char*, size_t) = 0;

    virtual const char* parse(const char*, size_t = 0) = 0;
    virtual Node* parseToNode(const char*, size_t = 0) = 0;

    virtual const char* parseNBest(size_t, const char*, size_t = 0) = 0;
    virtual bool  parseNBestInit(const char*, size_t = 0) = 0;
    virtual Node*  nextNode() = 0;
    virtual const char* next() = 0;
    virtual const char* formatNode(Node *) = 0;

    virtual const char* next(char*, size_t) = 0;
    virtual const char* parseNBest(size_t, const char*,
                                   size_t, char *, size_t) = 0;
    virtual const char* formatNode(Node *, char *, size_t) = 0;


    virtual bool  partial() const                             = 0;
    virtual void  set_partial(bool partial)                   = 0;
    virtual float theta() const                               = 0;
    virtual void  set_theta(float theta)                      = 0;
    virtual int   lattice_level() const                       = 0;
    virtual void  set_lattice_level(int level)                = 0;
    virtual bool  all_morphs() const                          = 0;
    virtual void  set_all_morphs(bool all_morphs)             = 0;

    virtual const char* what() = 0;

    virtual const DictionaryInfo* dictionary_info() const = 0;

    virtual ~Tagger() {};

    static const char *version();

    static Tagger* create(int, char**);
    static Tagger* create(const char*);
  };

  /* factory method */
  Tagger *createTagger (int, char**);
  Tagger *createTagger (const char*);
  const char* getTaggerError ();
}
</pre>

<h2><a name="c++-sample">C++ サンプル</a></h2>
<pre>
#include &lt;iostream&gt;
#include &lt;mecab.h&gt;

#define CHECK(eval) if (! eval) { \
   const char *e = tagger ? tagger->what() : MeCab::getTaggerError(); \
   std::cerr << "Exception:" << e << std::endl; \
   delete tagger; \
   return -1; }

int main (int argc, char **argv) {
  char input[1024] = "太郎は次郎が持っている本を花子に渡した。";

  MeCab::Tagger *tagger = MeCab::createTagger (argc, argv);
  CHECK(tagger);

  const char *result = tagger->parse(input);
  CHECK(result);
  std::cout << "INPUT: " << input << std::endl;
  std::cout << "RESULT: " << result << std::endl;

  result = tagger->parseNBest(3, input);
  CHECK(result);
  std::cout << "NBEST: " << std::endl << result;

  CHECK(tagger->parseNBestInit(input));
  for (int i = 0; i < 3; ++i) {
    std::cout << i << ":" << std::endl << tagger->next();
  }

  MeCab::Node* node = tagger->parseToNode(input);
  CHECK(node);
  for (; node; node = node->next) {
    std::cout.write(node->surface, node->length);
  }

  node = tagger->parseToNode(input);
  CHECK(node);

  for (; node; node = node->next) {
    std::cout << node->id << ' ';
    if (node->stat == MECAB_BOS_NODE)
      std::cout << "BOS";
    else if (node->stat == MECAB_EOS_NODE)
      std::cout << "EOS";
    else
      std::cout.write (node->surface, node->length);

    std::cout << ' ' << node->feature
	      << ' ' << (int)(node->surface - input)
	      << ' ' << (int)(node->surface - input + node->length)
	      << ' ' << node->rcAttr
	      << ' ' << node->lcAttr
	      << ' ' << node->posid
	      << ' ' << (int)node->char_type
	      << ' ' << (int)node->stat
	      << ' ' << (int)node->isbest
	      << ' ' << node->alpha
	      << ' ' << node->beta
	      << ' ' << node->prob
	      << ' ' << node->cost << std::endl;
  }

  delete tagger;

  return 0;
}

</pre>

<h2><a name="compile">コンパイル方法</a></h2>

<ul>
<li>UNIX の場合 </li>

<pre>
% cc -O2 `mecab-config --cflags` example.c -o example \
         `mecab-config --libs`
</pre>

<li>Windows の場合 </li>
<p>まず, コンパイル作業を行うディレクトリに include\mecab.h,
bin\libmecab.dll lib\libmecab.lib をコピーします.
この後の作業は, 使用するコンパイラによって微妙に変わります.</p>

<ul>
<li>cygwin/mingw 環境の場合</li>
<pre>
% gcc -DDLL_IMPORT -I. example.c -o example.exe libmecab.dll
</pre>

<li>VC++ 環境の場合</li>
<pre>
% cl -DDLL_IMPORT -I. example.c libmecab.lib
</pre>
</ul>
</ul>

<h2><a name="multi-thread">マルチスレッドについて</a></h2>
<p>MeCab は,マルチスレッド環境で使用することが可能です.
1つのスレッドに 1インスタンス(mecab_t *)を割り当てる場合はスレッドセーフです.
さらに, 同じ辞書を使い続ける限り,辞書を保持しているリソースは
再利用されるため, 複数のインスタンスを作成しても多くのメモリを使用することはありません.</p>

<p>一つのインスタンスを複数のスレッドから使う場合は適当に排他制御する必要があります.
ただし, パフォーマンスが悪いのでお勧めできません.
</p>

<hr>
<p>$Id: libmecab.html 161 2008-02-03 09:58:46Z taku-ku $;</p>
</body>
</html>

